import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { normalizePartyName, normalizeTin, getAllActiveParties } from '@/lib/partyResolver';

export async function GET(req: NextRequest) {
  try {
    const searchParams = req.nextUrl.searchParams;
    const countryCode = searchParams.get('country_code') || undefined;
    const search = searchParams.get('search');

    // If search query provided, do fuzzy search
    if (search) {
      const normalized = normalizePartyName(search);
      const parties = await prisma.party.findMany({
        where: {
          nameNormalized: {
            contains: normalized
          },
          deletedAt: null
        },
        select: {
          id: true,
          displayName: true,
          tinDisplay: true,
          countryCode: true,
          addressFull: true,
          email: true,
          createdAt: true
        },
        take: 50,
        orderBy: {
          displayName: 'asc'
        }
      });

      return NextResponse.json(parties);
    }

    // Otherwise, list all parties
    const parties = await getAllActiveParties(countryCode);

    return NextResponse.json(parties);
  } catch (error) {
    console.error('Error fetching parties:', error);
    return NextResponse.json(
      { error: { code: 'INTERNAL_ERROR', message: 'Failed to fetch parties' } },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { displayName, tinDisplay, countryCode, addressFull, email, createdBy } = body;

    // Validate required fields
    if (!displayName || !tinDisplay) {
      return NextResponse.json(
        { error: { code: 'INVALID_REQUEST', message: 'displayName and tinDisplay are required' } },
        { status: 400 }
      );
    }

    // Validate country code format
    if (countryCode && (countryCode.length !== 3 || countryCode !== countryCode.toUpperCase())) {
      return NextResponse.json(
        { error: { code: 'INVALID_COUNTRY_CODE', message: 'Country code must be 3-letter ISO code (uppercase)' } },
        { status: 400 }
      );
    }

    // Normalize for pre-checks (database will also normalize via trigger)
    const nameNormalized = normalizePartyName(displayName);
    const tinNormalized = normalizeTin(tinDisplay);

    // Check for existing party with same normalized name
    const existingByName = await prisma.party.findFirst({
      where: {
        nameNormalized,
        deletedAt: null
      },
      select: {
        id: true,
        displayName: true,
        tinDisplay: true,
        tinNormalized: true
      }
    });

    if (existingByName) {
      // Check if it's the same TIN (legitimate duplicate) or different TIN (collision)
      if (existingByName.tinNormalized !== tinNormalized) {
        return NextResponse.json(
          {
            error: {
              code: 'NAME_COLLISION',
              message: `Party name "${displayName}" already exists with different TIN`,
              existing: {
                id: existingByName.id,
                displayName: existingByName.displayName,
                tinDisplay: existingByName.tinDisplay
              }
            }
          },
          { status: 409 }
        );
      } else {
        // Same name + same TIN = duplicate entry
        return NextResponse.json(
          {
            error: {
              code: 'DUPLICATE_PARTY',
              message: `Party already exists`,
              existing: {
                id: existingByName.id,
                displayName: existingByName.displayName,
                tinDisplay: existingByName.tinDisplay
              }
            }
          },
          { status: 409 }
        );
      }
    }

    // Check for existing party with same TIN in same country
    const existingByTin = await prisma.party.findFirst({
      where: {
        tinNormalized,
        countryCode: countryCode || null,
        deletedAt: null
      },
      select: {
        id: true,
        displayName: true,
        tinDisplay: true
      }
    });

    if (existingByTin) {
      return NextResponse.json(
        {
          error: {
            code: 'DUPLICATE_TIN',
            message: `TIN "${tinDisplay}" already registered${countryCode ? ` in ${countryCode}` : ''}`,
            existing: {
              id: existingByTin.id,
              displayName: existingByTin.displayName,
              tinDisplay: existingByTin.tinDisplay
            }
          }
        },
        { status: 409 }
      );
    }

    // Create party (database triggers will auto-normalize)
    const party = await prisma.party.create({
      data: {
        displayName,
        nameNormalized: '', // Will be auto-generated by trigger
        tinDisplay,
        tinNormalized: '',  // Will be auto-generated by trigger
        countryCode: countryCode || null,
        addressFull: addressFull || null,
        email: email || null,
        createdBy: createdBy || null
      }
    });

    return NextResponse.json(party, { status: 201 });

  } catch (error: any) {
    console.error('Error creating party:', error);

    // Handle database constraint violations
    if (error.code === 'P2002') {
      return NextResponse.json(
        { error: { code: 'UNIQUENESS_VIOLATION', message: 'Party name or TIN already exists' } },
        { status: 409 }
      );
    }

    // Handle custom database errors (from triggers)
    if (error.code === '23505') {
      return NextResponse.json(
        { error: { code: 'COLLISION_DETECTED', message: error.message } },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { error: { code: 'INTERNAL_ERROR', message: 'Failed to create party' } },
      { status: 500 }
    );
  }
}
